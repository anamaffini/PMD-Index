# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PMDIndex
                                 A QGIS plugin
 This plugin calculates the Potential Movement Difference Index.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-15
        copyright            : (C) 2023 by Ana Luisa Maffini
        email                : analuisamaffini@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Ana Luisa Maffini'
__date__ = '2023-03-15'
__copyright__ = '(C) 2023 by Ana Luisa Maffini'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (NULL, QgsProcessing, QgsProcessingAlgorithm, QgsProject, QgsVectorFileWriter, QgsDistanceArea, QgsField, 
                       QgsProcessingParameterField, QgsProcessingParameterNumber, QgsProcessingParameterEnum,
                       QgsProcessing,  QgsProcessingAlgorithm, QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink, QgsField, QgsProject)

class PMDIndexAlgorithm(QgsProcessingAlgorithm):

    INPUT_VECTOR_LAYER = 'IMPUT_VECTOR_LAYER'
    ANALYSIS = 'ANALYSIS'
    GEOMRULE = 'GEOMRULE'    
    ID_FIELD = 'ID_FIELD'
    RADIUS = 'RADIUS'
    IMPEDANCE = 'IMPEDANCE'
    DESTINATION = 'DESTINATION'
    ORIGIN_GLOBAL = 'ORIGIN_GLOBAL'
    ORIGIN_A = 'ORIGIN_A'
    ORIGIN_B = 'ORIGIN_B'
    OUTPUT_VECTOR_LAYER = 'OUTPUT_VECTOR_LAYER'

    def initAlgorithm(self, config):
        
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_VECTOR_LAYER,
                self.tr('Input Vector Layer'),
                [QgsProcessing.TypeVectorAnyGeometry]))
        
        self.addParameter(
            QgsProcessingParameterEnum(
                self.ANALYSIS,
                self.tr('Analysis Type'),
                ['Topological Distance', 'Metric Distance'],
                defaultValue=[0]))            
        
        self.addParameter(
            QgsProcessingParameterEnum(
                self.GEOMRULE,
                self.tr('Rule for Connecting Lines'),
                ['Overlapping Vertices','Crossing Lines', 'Both the Above'],
                defaultValue=[0]))                
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.RADIUS,
                self.tr('Analysis Radius (0 = Global Analysis)'),
                QgsProcessingParameterNumber.Double))            
        
        self.addParameter(
            QgsProcessingParameterField(
                self.IMPEDANCE,
                self.tr('Impedance'),
                QgsProcessingParameterField.Numeric,
                parentLayerParameterName='IMPUT_VECTOR_LAYER',
                allowMultiple = False,
                optional = True))            
        
        self.addParameter(
            QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destinations'),
                QgsProcessingParameterField.Numeric,
                parentLayerParameterName='IMPUT_VECTOR_LAYER',
                allowMultiple = False,
                optional = False))            
        
        self.addParameter(
            QgsProcessingParameterField(
                self.ORIGIN_GLOBAL,
                self.tr('Origin of Entire Population (For GPM)'),
                QgsProcessingParameterField.Numeric,
                parentLayerParameterName='IMPUT_VECTOR_LAYER',
                allowMultiple = False,
                optional = False))             
        
        self.addParameter(
            QgsProcessingParameterField(
                self.ORIGIN_A,
                self.tr('Origin of Population Group A'),
                QgsProcessingParameterField.Numeric,
                parentLayerParameterName='IMPUT_VECTOR_LAYER',
                allowMultiple = False,
                optional = False))   
        
        self.addParameter(
            QgsProcessingParameterField(
                self.ORIGIN_B,
                self.tr('Origin of Population Group B'),
                QgsProcessingParameterField.Numeric,
                parentLayerParameterName='IMPUT_VECTOR_LAYER',
                allowMultiple = False,
                optional = False))    
        
        self.addParameter(                 
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_VECTOR_LAYER,
                self.tr('Output Vector Layer with Results'),
                type=QgsProcessing.TypeVectorAnyGeometry,
                createByDefault=False,
                supportsAppend=True,
                defaultValue=None))  

    def processAlgorithm(self, parameters, context, feedback):    
                             
        source = self.parameterAsSource(parameters, self.INPUT_VECTOR_LAYER, context)

        # Input Parameters
        inputEdges = self.parameterAsVectorLayer(parameters, self.INPUT_VECTOR_LAYER, context)
        metricsL = [0,1,2,3,4, 5, 6, 7]
        impField = self.parameterAsFields(parameters, self.IMPEDANCE, context)
        destinationField = self.parameterAsFields(parameters, self.DESTINATION, context)      
        originGField = self.parameterAsFields(parameters, self.ORIGIN_GLOBAL, context)
        originAField = self.parameterAsFields(parameters, self.ORIGIN_A, context)
        originBField = self.parameterAsFields(parameters, self.ORIGIN_B, context)
        analysisType = self.parameterAsEnum(parameters, self.ANALYSIS, context)
        radius = self.parameterAsDouble(parameters, self.RADIUS, context)
        geomR = self.parameterAsEnum(parameters, self.GEOMRULE, context)
        outPath = self.parameterAsOutputLayer(parameters, self.OUTPUT_VECTOR_LAYER, context) 
                                          
        # Edges of the network
        class EdgeObj:
            def __init__(self, featCount, feat, destinationF, originGF, originAF, originBF, impF, analysisType, metricsL):
                self.id = feat.id()
                self.heapPos = -1 #current position of the edge inside the heap
                self.neighA = [] #list of connected edges
                self.geom = feat.geometry()
                self.length = QgsDistanceArea().measureLength(feat.geometry()) if analysisType == 1 else 1
                
                if 0 in metricsL: self.gpm = 0
                if 1 in metricsL: self.pma = 0   
                if 2 in metricsL: self.pmb = 0            
                if 3 in metricsL: self.gpmNorm = 0
                if 4 in metricsL: self.pmaNorm = 0
                if 5 in metricsL: self.pmbNorm = 0
                if 6 in metricsL: self.pmda = 0
                if 7 in metricsL: self.pmdb = 0
                                                            
                self.destination, self.originG, self.originA, self.originB, self.imp = 0,0,0,0,0
                for i in range(len(destinationF)): 
                    if feat.attribute(destinationF[i]) != NULL: self.destination += feat.attribute(destinationF[i])                                     
                for i in range(len(originGF)): 
                    if feat.attribute(originGF[i]) != NULL: self.originG += feat.attribute(originGF[i]) 
                    else: 0                    
                for i in range(len(originAF)): 
                    if feat.attribute(originAF[i]) != NULL: self.originA += feat.attribute(originAF[i])
                    else: 0
                for i in range(len(originBF)): 
                    if feat.attribute(originBF[i]) != NULL: self.originB += feat.attribute(originBF[i])
                    else: 0
                if impF == ['0']: self.imp = 1
                else:
                    for i in range(len(impF)): 
                        if feat.attribute(impF[i]) != NULL: self.imp += feat.attribute(impF[i])    
                                       
        #verifies if highest id number is lower than number of features in order to avoid potential conflicts with matrices' size
        def verifyFeatCount(inputFeat):
            featCount = inputFeat.featureCount()
            for feat in inputFeat.getFeatures(): featCount = max(featCount, feat.id()+1)
            return featCount 
                 
        #edges initialization
        edgesCount = verifyFeatCount(inputEdges)
        edgesA = [] #array that stores network edges
        for edge in inputEdges.getFeatures():
            if edge.id() % 50 == 0: feedback.pushInfo(f'Initializing Edge {edge.id()}')
            edgesA.append(EdgeObj(edgesCount, edge, destinationField, originGField, originAField, originBField, impField, analysisType, metricsL))
            for i in range(len(edgesA)-1):
                if (geomR==0 and edgesA[-1].geom.touches(edgesA[i].geom)) or (geomR==1 and edgesA[-1].geom.crosses(edgesA[i].geom)) or (geomR==2 and (edgesA[-1].geom.crosses(edgesA[i].geom) or edgesA[-1].geom.touches(edgesA[i].geom))):
                        dist = (edgesA[-1].imp*edgesA[-1].length + edgesA[i].imp*edgesA[i].length)/2
                        if dist <= radius or radius == 0.0:
                            edgesA[-1].neighA.append([edgesA[i], dist])
                            edgesA[i].neighA.append([edgesA[-1], dist])

        #compute shortest paths (dijkstra algorithm with binary heap as priority queue)
        #step 1: heap creation
        for source in edgesA:
            if source.id % 50 == 0: feedback.pushInfo(f'Shortest Paths Edge {source.id}')
            finitePos = 0
            costA = [99999999999999 for i in range(edgesCount)]
            costA[source.id] = 0 #distance from the source edge to itself is zero
            for ind in range(len(source.neighA)): costA[source.neighA[ind][0].id] = source.neighA[ind][1]
            heap = [edgesA[0] for i in range(len(source.neighA) + 1)]
            for destin in edgesA:
                if costA[destin.id] == 99999999999999:
                    heap.append(destin)
                    destin.heapPos = len(heap) - 1
                else:
                    heap[finitePos] = destin
                    destin.heapPos = finitePos
                    n = finitePos
                    finitePos += 1
                    parent = int((n-1)/2)
                    while n !=0 and costA[heap[n].id] < costA[heap[parent].id]:
                        heap[n].heapPos, heap[parent].heapPos = parent, n
                        heap[n], heap[parent] = heap[parent], heap[n]
                        n = parent
                        parent = int((n-1)/2)              
    #step 2 heapsort
            pivotA = [[] for i in range(edgesCount)] #array of pivot edges in shortest paths
            level = [99999999999999 for i in range(edgesCount)]
            sortedA = []
            numSP = [0 for i in range(edgesCount)]
            numSP[source.id], level[source.id] = 1,0
            for ind in range(len(source.neighA)):
                numSP[source.neighA[ind][0].id] = 1
                level[source.neighA[ind][0].id] = 1
            while heap != []:
                closest = heap[0]
                if costA[closest.id] <= radius or radius == 0.0: sortedA.append(closest)
                if finitePos > 0:
                    heap[0].heapPos, heap[finitePos-1].heapPos = finitePos-1, 0
                    heap[0], heap[finitePos-1] = heap[finitePos-1], heap[0]
                    heap[finitePos-1].heapPos, heap[-1].heapPos = len(heap)-1, finitePos-1
                    heap[finitePos-1], heap[-1] = heap[-1], heap[finitePos-1]
                    finitePos -= 1
                heap.pop(len(heap)-1)
                
                n = 0
                lh = finitePos
                posChild1, posChild2 = n*2+1, n*2+2
                if posChild2 <= lh-1:
                    costChild1, costChild2 = costA[heap[n*2+1].id], costA[heap[n*2+2].id]
                    if any(x < costA[heap[n].id] for x in [costChild1,costChild2]):
                        if costChild1 <= costChild2: sc = posChild1
                        else: sc = posChild2
                    else: sc = -1
                elif posChild2 == lh:
                    if costA[heap[n*2+1].id] < costA[heap[n].id]: sc = posChild1
                    else: sc = -1
                else: sc = -1
                    
                while sc >= 0:
                    heap[n].heapPos, heap[sc].heapPos = sc, n
                    heap[n], heap[sc] = heap[sc], heap[n]
                    n = sc
                    lh = len(heap)
                    posChild1, posChild2 = n*2+1, n*2+2
                    if posChild2 <= lh-1:
                        costChild1, costChild2 = costA[heap[n*2+1].id], costA[heap[n*2+2].id]
                        if any(x < costA[heap[n].id] for x in [costChild1,costChild2]):
                            if costChild1 <= costChild2: sc = posChild1
                            else: sc = posChild2
                        else: sc = -1
                    elif posChild2 == lh:
                        if costA[heap[n*2+1].id] < costA[heap[n].id]: sc = posChild1
                        else: sc = -1
                    else: sc = -1
                    
                for ind in range(len(closest.neighA)):
                    if closest.neighA[ind][0].heapPos < len(heap):
                        cost = costA[closest.id] + closest.neighA[ind][1]
                        prevCost = costA[closest.neighA[ind][0].id]
                        if prevCost > cost and (radius == 0.0 or cost <= radius):
                            costA[closest.neighA[ind][0].id], level[closest.neighA[ind][0].id] = cost, level[closest.id] + 1
                            pivotA[closest.neighA[ind][0].id] = []
                            pivotA[closest.neighA[ind][0].id].append(closest)
                            numSP[closest.neighA[ind][0].id] += numSP[closest.id]
                            
                            n = closest.neighA[ind][0].heapPos
                            if prevCost == 99999999999999: 
                                heap[finitePos].heapPos, closest.neighA[ind][0].heapPos = n, finitePos
                                heap[n], heap[finitePos] = heap[finitePos], closest.neighA[ind][0]
                                n = finitePos
                                finitePos += 1
                            parent = int((n-1)/2)
                            while n !=0 and costA[heap[n].id] < costA[heap[parent].id]:
                                heap[n].heapPos, heap[parent].heapPos = parent, n
                                heap[n], heap[parent] = heap[parent], heap[n]
                                n = parent
                                parent = int((n-1)/2)

                        elif source.id != closest.id and costA[closest.neighA[ind][0].id] == cost and (radius == 0.0 or cost <= radius):
                            pivotA[closest.neighA[ind][0].id].append(closest)
                            numSP[closest.neighA[ind][0].id] += numSP[closest.id]       
        #step 3 metrics
            if 0 in metricsL: gpmTemp = [0 for i in range(edgesCount)]
            if 1 in metricsL: pmaTemp = [0 for i in range(edgesCount)]
            if 2 in metricsL: pmbTemp = [0 for i in range(edgesCount)]
            if 3 in metricsL: gpmNormTemp = [0 for i in range(edgesCount)]
            if 4 in metricsL: pmaNormTemp = [0 for i in range(edgesCount)]  
            if 5 in metricsL: pmbNormTemp = [0 for i in range(edgesCount)] 
                                                                
            originGtot = sum([edge.originG for edge in edgesA])
            originAtot = sum([edge.originA for edge in edgesA])
            originBtot = sum([edge.originB for edge in edgesA])
            
            while sortedA != []:
                farest = sortedA[-1]
                cost = costA[farest.id]                                       
                sortedA.pop(len(sortedA)-1)
                tensionG = source.destination * farest.originG
                tensionA = source.destination * farest.originA
                tensionB = source.destination * farest.originB
                                                     
                for neigh in pivotA[farest.id]:
                    if numSP[farest.id] > 0 and (radius == 0.0 or cost <= radius):
                        if 0 in metricsL: gpmTemp[neigh.id] += (numSP[neigh.id]/numSP[farest.id])*((tensionG/(level[farest.id]+1))+gpmTemp[farest.id])
                        if 1 in metricsL: pmaTemp[neigh.id] += (numSP[neigh.id]/numSP[farest.id])*((tensionA/(level[farest.id]+1))+pmaTemp[farest.id])
                        if 2 in metricsL: pmbTemp[neigh.id] += (numSP[neigh.id]/numSP[farest.id])*((tensionB/(level[farest.id]+1))+pmbTemp[farest.id])
                                      
                    
                if pivotA[farest.id] == [] and level[farest.id] == 1 and (radius == 0.0 or cost <= radius): 
                    if 0 in metricsL: gpmTemp[source.id] += (numSP[neigh.id]/numSP[farest.id])*((tensionG/(level[farest.id]+1))+gpmTemp[farest.id])
                    if 1 in metricsL: pmaTemp[source.id] += (numSP[neigh.id]/numSP[farest.id])*((tensionA/(level[farest.id]+1))+pmaTemp[farest.id])
                    if 2 in metricsL: pmbTemp[source.id] += (numSP[neigh.id]/numSP[farest.id])*((tensionB/(level[farest.id]+1))+pmbTemp[farest.id])
                   
                    
                if (0 in metricsL) and (radius == 0.0 or cost <= radius): gpmTemp[farest.id] += tensionG/(level[farest.id]+1)
                if (1 in metricsL) and (radius == 0.0 or cost <= radius): pmaTemp[farest.id] += tensionA/(level[farest.id]+1)
                if (2 in metricsL) and (radius == 0.0 or cost <= radius): pmbTemp[farest.id] += tensionB/(level[farest.id]+1)
                if (3 in metricsL) and (radius == 0.0 or cost <= radius): gpmNormTemp[farest.id] += gpmTemp[farest.id]/originGtot
                if (4 in metricsL) and (radius == 0.0 or cost <= radius): pmaNormTemp[farest.id] += pmaTemp[farest.id]/originAtot
                if (5 in metricsL) and (radius == 0.0 or cost <= radius): pmbNormTemp[farest.id] += pmbTemp[farest.id]/originBtot
                
                if 0 in metricsL: farest.gpm += gpmTemp[farest.id]
                if 1 in metricsL: farest.pma += pmaTemp[farest.id]
                if 2 in metricsL: farest.pmb += pmbTemp[farest.id]
                if 3 in metricsL: farest.gpmNorm += gpmNormTemp[farest.id]
                if 4 in metricsL: farest.pmaNorm += pmaNormTemp[farest.id]
                if 5 in metricsL: farest.pmbNorm += pmbNormTemp[farest.id]
                if 6 in metricsL: farest.pmda += (pmaNormTemp[farest.id] - gpmNormTemp[farest.id])
                if 7 in metricsL: farest.pmdb += (pmbNormTemp[farest.id] - gpmNormTemp[farest.id])     

        #update table of contents
        strBegin = "T" if analysisType == 0 else "G"
        strMid = "g" if radius == 0.0 else str(int(radius))
        if len(strMid) > 5: strBegin += strMid[0:5]
        else: strBegin += strMid               
        
        if 0 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "GPM")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "GPM",QVariant.Double)])
            inputEdges.updateFields()
            gpmIndex = inputEdges.fields().indexFromName(strBegin + "GPM")            
        if 1 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "PMa")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "PMa",QVariant.Double)])
            inputEdges.updateFields()
            pmaIndex = inputEdges.fields().indexFromName(strBegin + "PMa")   
        if 2 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "PMb")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "PMb" ,QVariant.Double)])
            inputEdges.updateFields()
            pmbIndex = inputEdges.fields().indexFromName(strBegin + "PMb") 
        if 3 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "GPMNorm")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "GPMNorm",QVariant.Double)])
            inputEdges.updateFields()
            gpmNormIndex = inputEdges.fields().indexFromName(strBegin + "GPMNorm") 
        if 4 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "PMaNorm")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "PMaNorm",QVariant.Double)])
            inputEdges.updateFields()
            pmaNormIndex = inputEdges.fields().indexFromName(strBegin + "PMaNorm")
        if 5 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "PMbNorm")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "PMbNorm",QVariant.Double)])
            inputEdges.updateFields()
            pmbNormIndex = inputEdges.fields().indexFromName(strBegin + "PMbNorm") 
        if 6 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "PMDa")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "PMDa",QVariant.Double)])
            inputEdges.updateFields()
            pmdaIndex = inputEdges.fields().indexFromName(strBegin + "PMDa") 
        if 7 in metricsL:
            inputEdges.fields().indexFromName(strBegin + "PMDb")
            inputEdges.dataProvider().addAttributes([QgsField(strBegin + "PMDb",QVariant.Double)])
            inputEdges.updateFields()
            pmdbIndex = inputEdges.fields().indexFromName(strBegin + "PMDb")        
            
        for edge in edgesA:
            metricsD = {}
            if 0 in metricsL: metricsD[gpmIndex] = edge.gpm
            if 1 in metricsL: metricsD[pmaIndex] = edge.pma  
            if 2 in metricsL: metricsD[pmbIndex] = edge.pmb
            if 3 in metricsL: metricsD[gpmNormIndex]= edge.gpmNorm
            if 4 in metricsL: metricsD[pmaNormIndex] = edge.pmaNorm
            if 5 in metricsL: metricsD[pmbNormIndex] = edge.pmbNorm
            if 6 in metricsL: metricsD[pmdaIndex] = edge.pmda
            if 7 in metricsL: metricsD[pmdbIndex] = edge.pmdb
            inputEdges.dataProvider().changeAttributeValues({edge.id : metricsD})       
        
        if outPath != "":
            crs = QgsProject.instance().crs()                            
            save_options = QgsVectorFileWriter.SaveVectorOptions()
            save_options.driverName = "ESRI Shapefile"
            save_options.fileEncoding = "System"
            context = QgsProject.instance().transformContext()  
            QgsVectorFileWriter.writeAsVectorFormat(inputEdges, outPath, "System", crs, "ESRI Shapefile")
            metricsOut = []
            if 0 in metricsL: metricsOut.append(gpmIndex)
            if 1 in metricsL: metricsOut.append(pmaIndex)   
            if 2 in metricsL: metricsOut.append(pmbIndex)  
            if 3 in metricsL: metricsOut.append(gpmNormIndex)  
            if 4 in metricsL: metricsOut.append(pmaNormIndex)   
            if 5 in metricsL: metricsOut.append(pmbNormIndex)   
            if 6 in metricsL: metricsOut.append(pmdaIndex)   
            if 7 in metricsL: metricsOut.append(pmdbIndex)                    
            inputEdges.dataProvider().deleteAttributes(metricsOut)
            inputEdges.updateFields()
   
        return {self.OUTPUT_VECTOR_LAYER: outPath} #Return the results of the algorithm  
            
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Potential Movement Difference Index'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('PMD Index')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def shortHelpString(self):
        """
        Returns a localised short helper string for the algorithm. This string
        should provide a basic description about what the algorithm does and the
        parameters and outputs associated with it.
        """
        return self.tr(
            """
            Input Vector Layer: LineString shapefile of the network. For metric calculations the CRS must be a projected CRS.
            Analysis Type: How the distance between lines is computed. In the topological analysis, the distance between each pair of connected lines is 1. In the metric analysis, the Euclidean distances between the centroids of adjacent lines are considered.
            Analysis Radius: Zero means that all lines will be considered for the computation. A value higher than zero means that only the lines within the defined radius will be considered for the computation.
            Rule for Connecting the Lines: Definition of how the connection between lines will be computed.
            Impedance: Field of the selected input shapefile containing the impedance values of each line.
            Destinations: Field of the selected input shapefile containing the destinations values of each line.
            Origin Of Entire Population: Field of the selected input shapefile containing the origins value for the entire population of each line.
            Origin of Population Group A: Field of the selected input shapefile containing the origins value for the population of group A of each line.
            Origin of Population Group B: Field of the selected input shapefile containing the origins value for the population of group B of each line.
            Output Vector Layer: A new shapefile will be created containing the results.
            """)
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PMDIndexAlgorithm()
    
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(__file__), 'icons/pmd.png'))